<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebrew PDF Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            background: #f0f2f5;
            padding: 20px;
            text-align: center;
        }
        .container {
            background: white;
            padding: 25px;
            border-radius: 12px;
            max-width: 600px;
            margin: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 16px;
            text-align: right;
            margin-bottom: 20px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
        }
        #status {
            margin-top: 15px;
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

    <div class="container">
        <h2>מחולל PDF (גרסה אמינה)</h2>
        <p>This method generates a real PDF file to prevent cutting on iOS.</p>
        <textarea id="wordInput" placeholder="הדבק מילים כאן..."></textarea>
        <button onclick="generateRealPDF()">Generate Real PDF</button>
        <div id="status"></div>
    </div>

    <script>
        // Helper to fetch font file as binary data
        async function loadFont(url) {
            const response = await fetch(url);
            const buffer = await response.arrayBuffer();
            return arrayBufferToBase64(buffer);
        }

        // Standard buffer to base64 conversion
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        async function generateRealPDF() {
            const input = document.getElementById('wordInput').value;
            const statusDiv = document.getElementById('status');
            
            let words = input.split('\n').map(w => w.trim()).filter(w => w.length > 0);
            if (words.length === 0) { alert("Please enter words."); return; }

            statusDiv.innerText = "Loading Hebrew fonts and generating... please wait.";

            try {
                // 1. Initialize jsPDF
                const { jsPDF } = window.jspdf;
                // A4 Portrait: 210mm width, 297mm height
                const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });

                // 2. Load and add a Hebrew font (Rubik from Google Fonts)
                // We must load a font that supports Hebrew characters. Standard PDF fonts do not.
                const fontURL = 'https://github.com/google/fonts/raw/main/ofl/rubik/Rubik-Regular.ttf';
                const fontBase64 = await loadFont(fontURL);
                
                doc.addFileToVFS('Rubik-Regular.ttf', fontBase64);
                doc.addFont('Rubik-Regular.ttf', 'Rubik', 'normal');
                doc.setFont('Rubik');

                // 3. Configuration for layout
                const margin = 12; // 12mm safe margin all around
                const pageWidth = 210;
                const pageHeight = 297;
                const printableWidth = pageWidth - (margin * 2); // 186mm
                const printableHeight = pageHeight - (margin * 2); // 273mm
                
                const cols = 2;
                const rows = 4;
                const cardWidth = printableWidth / cols; // 93mm
                const cardHeight = printableHeight / rows; // 68.25mm

                // 4. Shuffle & Group Words
                for (let i = words.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [words[i], words[j]] = [words[j], words[i]];
                }
                const wordsPerCard = 4;
                const cardsPerPage = cols * rows;
                let cards = [];
                for (let i = 0; i < words.length; i += wordsPerCard) cards.push(words.slice(i, i + wordsPerCard));
                let pages = [];
                for (let i = 0; i < cards.length; i += cardsPerPage) pages.push(cards.slice(i, i + cardsPerPage));

                // 5. Draw the PDF
                pages.forEach((pageCards, pageIdx) => {
                    if (pageIdx > 0) doc.addPage();
                    
                    doc.setLineWidth(0.3);
                    doc.setDrawColor(150); // Gray color for lines
                    doc.setLineDashPattern([3, 3], 0); // Dashed lines

                    pageCards.forEach((cardWords, cardIdx) => {
                        // Calculate grid position
                        const colIdx = cardIdx % cols; // 0 or 1
                        const rowIdx = Math.floor(cardIdx / cols); // 0 to 3

                        // Calculate absolute coordinates on paper
                        // Important for RTL: Col 0 is on the RIGHT side visually
                        // So if colIdx is 0, x is margin + cardWidth. If colIdx is 1, x is margin.
                        const xPos = margin + ((cols - 1 - colIdx) * cardWidth);
                        const yPos = margin + (rowIdx * cardHeight);

                        // Draw Cell Border (Dashed)
                        doc.rect(xPos, yPos, cardWidth, cardHeight);

                        // Draw Text
                        doc.setFontSize(14);
                        doc.setTextColor(0); // Black
                        
                        const textStartX = xPos + cardWidth - 10; // Start 10mm from right edge of card
                        let textStartY = yPos + 20; // Start 20mm from top edge of card
                        const lineHeight = 8;

                        cardWords.forEach((word, wIdx) => {
                            const textLine = `${wIdx + 1}. ${word}`;
                            // rtl: true handles Hebrew direction automatically
                            doc.text(textLine, textStartX, textStartY + (wIdx * lineHeight), { align: 'right', rtl: true });
                        });
                    });
                });

                statusDiv.innerText = "Done! Opening PDF...";
                
                // 6. Output for iOS
                // This forces Safari to open the raw PDF data in the current window
                doc.output('dataurlnewwindow');
                statusDiv.innerText = ""; // Clear status

            } catch (e) {
                alert("Error generating PDF. Ensure internet connection for font download.\n" + e.message);
                statusDiv.innerText = "Error failed.";
            }
        }
    </script>
</body>
</html>
