<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebrew Cards PDF</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            background: #f0f2f5;
            padding: 20px;
            text-align: center;
        }
        .container {
            background: white;
            padding: 25px;
            border-radius: 12px;
            max-width: 600px;
            margin: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 16px;
            text-align: right;
            margin-bottom: 20px;
        }
        button {
            background-color: #2f855a;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            font-weight: bold;
        }
        #status {
            margin-top: 15px;
            color: #555;
            font-size: 0.9em;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="container">
        <h2>מחולל PDF (פונט מקומי)</h2>
        <p>Ensure <strong>GoogleSans_17pt-Medium.ttf</strong> is in the same folder as this file.</p>
        <textarea id="wordInput" placeholder="הדבק מילים כאן..."></textarea>
        <button onclick="generateRealPDF()">Generate PDF</button>
        <div id="status"></div>
    </div>

    <script>
        // Helper: Convert binary font data to Base64
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        async function generateRealPDF() {
            const input = document.getElementById('wordInput').value;
            const statusDiv = document.getElementById('status');
            
            let words = input.split('\n').map(w => w.trim()).filter(w => w.length > 0);
            if (words.length === 0) { alert("אנא הכנס מילים"); return; }

            statusDiv.innerText = "Generating PDF...";

            try {
                const { jsPDF } = window.jspdf;
                // A4 Portrait
                const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });

                // --- FONT LOADING SECTION ---
                // We use the exact filename you provided
                const fontFilename = 'GoogleSans_17pt-Medium.ttf';
                
                try {
                    const response = await fetch(fontFilename);
                    if (!response.ok) throw new Error("Could not find font file.");
                    const buffer = await response.arrayBuffer();
                    const fontBase64 = arrayBufferToBase64(buffer);

                    // Add font to PDF
                    doc.addFileToVFS(fontFilename, fontBase64);
                    doc.addFont(fontFilename, 'MyHebrewFont', 'normal');
                    doc.setFont('MyHebrewFont');
                } catch (fontError) {
                    alert("Error loading font: " + fontFilename + "\nMake sure the file is in the root folder.");
                    statusDiv.innerText = "Font load failed.";
                    return;
                }

                // --- PDF LAYOUT CALCULATIONS ---
                const margin = 10; 
                const pageWidth = 210;
                const pageHeight = 297;
                
                // 2 Cols x 4 Rows
                const cols = 2;
                const rows = 4;
                
                const printableWidth = pageWidth - (margin * 2);
                const printableHeight = pageHeight - (margin * 2);
                
                const cardWidth = printableWidth / cols;   // ~95mm
                const cardHeight = printableHeight / rows; // ~69mm

                // Shuffle
                for (let i = words.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [words[i], words[j]] = [words[j], words[i]];
                }

                // Chunking
                const wordsPerCard = 4;
                const cardsPerPage = cols * rows;
                let cards = [];
                for (let i = 0; i < words.length; i += wordsPerCard) {
                    cards.push(words.slice(i, i + wordsPerCard));
                }
                let pages = [];
                for (let i = 0; i < cards.length; i += cardsPerPage) {
                    pages.push(cards.slice(i, i + cardsPerPage));
                }

                // --- DRAWING ---
                pages.forEach((pageCards, pageIdx) => {
                    if (pageIdx > 0) doc.addPage();
                    
                    // Set styles
                    doc.setLineWidth(0.1); 
                    doc.setDrawColor(100); // Dark Gray lines
                    doc.setLineDashPattern([3, 3], 0); // Dashed lines for cutting

                    pageCards.forEach((cardWords, cardIdx) => {
                        // Calculate position
                        const colIdx = cardIdx % cols; 
                        const rowIdx = Math.floor(cardIdx / cols);

                        // RTL Logic for Columns: Col 0 is visually on the Right
                        // xPos is the top-left corner of the cell
                        const xPos = margin + ((cols - 1 - colIdx) * cardWidth);
                        const yPos = margin + (rowIdx * cardHeight);

                        // Draw Border
                        doc.rect(xPos, yPos, cardWidth, cardHeight);

                        // Text Settings
                        doc.setFontSize(14);
                        doc.setTextColor(0);

                        // Text alignment
                        // We align RIGHT. The X coordinate for right-alignment is (xPos + cardWidth - padding)
                        const textRightEdge = xPos + cardWidth - 10;
                        const textTopStart = yPos + 25; // 25mm from top of card
                        const lineHeight = 9;

                        cardWords.forEach((word, wIdx) => {
                            const textLine = `${wIdx + 1}. ${word}`;
                            doc.text(textLine, textRightEdge, textTopStart + (wIdx * lineHeight), { 
                                align: 'right', 
                                rtl: true 
                            });
                        });
                    });
                });

                statusDiv.innerText = "Done! Opening...";
                
                // Open PDF in new window (forces iOS viewer)
                doc.output('dataurlnewwindow');
                
            } catch (e) {
                console.error(e);
                alert("An error occurred: " + e.message);
            }
        }
    </script>
</body>
</html>
